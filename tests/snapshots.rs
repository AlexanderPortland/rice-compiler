use anyhow::Result;
use regex::Regex;
use rice::bc::types::AllocLoc;
use serde::Serialize;
use std::{collections::BTreeMap, fs, path::Path, process::Command};
use walkdir::WalkDir;

#[derive(Serialize)]
struct CompilerOutput {
    success: bool,
    stdout: String,
    stderr: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    stats: Option<CompilationStats>,
}

#[derive(Serialize)]
/// Statistics about our generated bytecode & its execution to prevent performance regressions.
struct CompilationStats {
    /// The total number of statements in our bytecode (including terminators)
    bc_stmts: usize,
    /// The number of locals in our bytecode
    bc_locals: usize,
    /// The number of basic blocks in our bytecode
    bc_blocks: usize,
    /// The total number of function calls when executing the program.
    exec_calls: usize,
    /// The total number of steps taken to execute the program
    exec_steps: usize,
    #[serde(skip_serializing_if = "BTreeMap::is_empty")]
    allocs: BTreeMap<AllocLoc, usize>,
}

fn compile(path: &Path, args: &str) -> Result<CompilerOutput> {
    let mut cmd = Command::new("./target/debug/rice");
    cmd.arg(path);
    cmd.args(shlex::split(args).unwrap());
    println!("running command {:?}", cmd);
    let output = cmd.output()?;
    let success = output.status.success();

    let stats = success.then(|| get_bytecode_stats(path, args));

    println!("stats got");

    Ok(CompilerOutput {
        success: output.status.success(),
        stats,
        stdout: String::from_utf8(output.stdout)?,
        stderr: String::from_utf8(output.stderr)?,
    })
}

/// Recompile with debug to check for stack allocations & loc
fn get_bytecode_stats(path: &Path, args: &str) -> CompilationStats {
    let mut cmd = Command::new("./target/debug/rice");
    cmd.arg(path);
    cmd.env("RUST_LOG", "rice=debug");
    cmd.args(shlex::split(args).unwrap());
    println!("running command {:?}", cmd);
    let output = cmd.output().expect("should run");

    let full_output_str = String::from_utf8(output.stderr).expect("shd");

    let start = full_output_str
        .as_str()
        .match_indices("] Optimized BC:")
        .last()
        .unwrap_or_else(|| {
            full_output_str
                .as_str()
                .match_indices("] Initial BC:")
                .last()
                .expect("should have A bytecode output")
        });
    let start_i = start.0 + start.1.len();

    let output_str = &full_output_str[start_i..];
    let output_str = &output_str[..output_str.find("\n[").unwrap_or(output_str.len())];

    let alloc_locs = [(AllocLoc::Heap, "Heap"), (AllocLoc::Stack, "Stack")];

    let re = Regex::new(r"RT:\s*\n?\s*calls:\s*(\d+),\s*steps:\s*(\d+)").unwrap();
    let caps = re.captures(&full_output_str).expect("should match RT");

    let rt_calls: usize = caps[1].parse().unwrap();
    let rt_steps: usize = caps[2].parse().unwrap();

    let bc_blocks = Regex::new("\n\\s*bb\\d+:")
        .unwrap()
        .find_iter(output_str)
        .count();

    CompilationStats {
        allocs: alloc_locs
            .iter()
            .filter_map(|(loc, name)| {
                let num = output_str.matches(&format!("@ {name}")).count();
                if num > 0 { Some((*loc, num)) } else { None }
            })
            .collect(),
        bc_locals: Regex::new(r"\n\s*local\s+x?\d+:")
            .unwrap()
            .find_iter(output_str)
            .count(),
        bc_blocks,
        // All statements have an equals sign, plus a terminator for each basic block.
        bc_stmts: output_str.lines().filter(|l| l.contains("=")).count() + bc_blocks,
        exec_steps: rt_steps,
        exec_calls: rt_calls,
    }
}

#[test]
fn snapshots() -> Result<()> {
    let root = Path::new("tests/programs").canonicalize()?;
    for entry in WalkDir::new(&root) {
        let entry = entry?;
        if !entry.file_type().is_file() {
            continue;
        }

        let path = entry.path();
        let ext = path.extension().unwrap().to_str().unwrap();
        if ext != "rice" {
            continue;
        }

        let contents = fs::read_to_string(path)?;
        let first_line = contents.lines().next().unwrap();
        let args = match first_line.strip_prefix("//") {
            Some(args) => args,
            None => "",
        };

        // Compile without optimizations first...
        let output = compile(path, &("".to_string() + args))?;
        let name = path.file_name().unwrap().to_str().unwrap().to_string() + "";
        let snapshot_path = path.parent().unwrap();
        insta::with_settings!({
          snapshot_path => snapshot_path,
          prepend_module_to_snapshot => false,
          filters => vec![
            (r"thread 'main' \((.*?)\)", r"thread 'main' ([some PID])")
          ],
        }, {
          insta::assert_toml_snapshot!(name, output);
        });

        // Compile with optimizations too to ensure they don't affect program behavior.
        let output = compile(path, &(" -O1".to_string() + args))?;
        let name = path.file_name().unwrap().to_str().unwrap().to_string() + ".opt";
        let snapshot_path = path.parent().unwrap();
        insta::with_settings!({
          snapshot_path => snapshot_path,
          prepend_module_to_snapshot => false,
          filters => vec![
            (r"thread 'main' \((.*?)\)", r"thread 'main' ([some PID])")
          ],
        }, {
          insta::assert_toml_snapshot!(name, output);
        });
    }
    Ok(())
}
